---
output: 
  pdf_document:
    citation_package: natbib
    keep_tex: true
    fig_caption: true
    latex_engine: xelatex
    template: https://raw.githubusercontent.com/svmiller/svm-r-markdown-templates/master/svm-latex-ms.tex
title: "White Advantage in Chess and How to Counter It"
author:
- name: Jun Won (Lakon) Park (Group Leader)
  affiliation: 79453940, Group Leader, data collection, data analysis, report-writing
- name: Sarah Li
  affiliation: 60136959, data collection, data analysis, report-writing
abstract: "Research question: Is white at an advantage in chess and if so, what are some optimal strategies for black to increase their winning probability?"
date: "`r format(Sys.time(), '%B %d, %Y')`"
geometry: margin=1in
fontfamily: mathpazo
fontsize: 11pt
# spacing: double
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(leaps)
library(lubridate)
library(stringr)
library(MASS)
library(car)
library(boot)
library(sjPlot)
library(sjmisc)
library(sjlabelled)
library(stargazer)
library(tidyverse)
```

### Introduction
For several centuries, millions of people worldwide have been playing chess as a recreational and competitive board game at their homes, in clubs, in tournaments, and even online nowadays. In the recent decades, chess has been one of the most popular topic in machine learning and artificial intelligence. The first move advantage has been researched extensively since the end of 18th century, and many studies have been shown that white has an inherent advantage.   
\newline
Although there are general set chess openings for black according to white's first move, less research has been done on the effects of those openings on the final outcome. This paper intends to confirm white's first move advantage and study the relationship between the openings and the victory status.  
\newline
This paperâ€™s data collection consists basic player information and game information of over 20000 chess games obtained exclusively from Lichess, a very popular internet chess platform. The data includes game length, number of turns, winner, player elo$^*$, all moves in Standard Chess Notation, Opening Eco$^*$, Opening Name, and Opening Ply$^*$ (some stuff about sampling method and target population)
\newline
\newline
----------------------------------------------------------
\begin{flushleft}
Elo : A numerical measurement to quantify a player's skill level\newline
Eco : Standardised code for any given opening\newline
Ply : Number of moves in the opening phasenewline
\pagebreak
\end{flushleft}
----------------------------------------------------------
\begin{flushleft}
\end{flushleft}

### Analysis

```{r srs}
# Load data
df <- read.csv("games.csv")

# Calculate the average elo of the game
df <- mutate(df %>% rowwise(),
       average_elo = rowMeans(cbind(black_rating,white_rating)))

# Filter games by average elo
df <- filter(df, average_elo >= 1200)

# Filter games by average elo
df <- filter(df, victory_status != "outoftime")

df <- subset(df, 
             select = c(turns, white_rating, black_rating, victory_status, 
                        winner, moves, opening_eco, opening_name, opening_ply, average_elo ))

# Simple Random Sampling
N <- nrow(df)
n <- 2000
set.seed(1234)
sample.index <- sample(1:N, size=n, replace = FALSE)
srs.sample <- df[sample.index,]
```


```{r stratified}
# Determine minimum and maximum before stratifying
min(df$average_elo)
max(df$average_elo)

# Stratified sampling
df$elo_range <- cut(df$average_elo, 
                    c(1200, 1400, 1600, 1800, 2000, 2200, 2400, 2600))
levels(df$elo_range) <- c("1200-1400", "1400-1600", "1600-1800", "1800-2000", 
                          "2000-2200", "2200-2400", "2400+")
df$winner <- as.factor(df$winner)
# levels(df$winner) <- list("white"=c("white"), 
#                           "black"=c("black")
#                           "not_white"=c("black", "draw"))

# Check if standard deviations of the strata are identical
se.by.strata <- aggregate(as.numeric(df$winner), by=list(df$elo_range), FUN=sd)
se.by.strata

# Standard deviations within strata are not identical, \
# so find optimal sample sizes
pop.size.by.strata <- aggregate(df$winner, by=list(df$elo_range), FUN=length)
denom <- sum(pop.size.by.strata[2] * se.by.strata[2])
sample.size.by.strata <- (pop.size.by.strata[2] * se.by.strata[2]) / denom


# Sample from each strata
stratified_sample <- df[FALSE,]
colnames(stratified_sample) <- names(df)
for (i in 1:length(levels(df$elo_range))) {
  strata <- which(df$elo_range == levels(df$elo_range)[i])
  sample_indices <- sample(strata, 
                           size = ceiling(sample.size.by.strata$x[i] * n), 
                           replace = FALSE)
  sample <- df[sample_indices,]
  stratified_sample <- rbind(stratified_sample, sample)
}
table <- table(stratified_sample$elo_range)
table

# Stratified sample contains 1003 samples due to rounding of the proportions,
# so we randomly remove three from random strata
strata_for_removal <- sample(1:7, 3)
for (s in strata_for_removal) {
  to_remove <- sample(which(stratified_sample$elo_range == levels(df$elo_range)[s]), 1)
  stratified_sample <- stratified_sample[-to_remove,]
}
table(stratified_sample$elo_range)

```

```{r srs analysis}
z.95 <- qnorm(0.975)
# Calculate white's win rate
win.prop <- srs.sample %>%
  count(winner) %>%
  group_by(winner) %>%
  mutate(win.prop = n / N)

white.p <- as.numeric(win.prop[3,3])
black.p <- as.numeric(win.prop[1,3])

srs.se <- sqrt((1-n/N)*(white.p * (1-white.p) + black.p * (1-black.p) - 2*white.p*black.p)/n)

(white.p-black.p) + z.95 * srs.se * c(-1, 1)
```

```{r stratified sampling analysis}
strata <- c("1200-1400", "1400-1600", "1600-1800", "1800-2000", 
                          "2000-2200", "2200-2400", "2400+")
stratified_sample <- stratified_sample %>% group_by(elo_range) 

# Calculate Nh/N, the strata proportion
Nh <- df %>% count(elo_range)
nh <- stratified_sample %>% count(elo_range)
strata.size.prop <- Nh[2] / N

# Calculate white's win proportion by each strata
win.prop <- stratified_sample %>%
  count(winner) %>%
  group_by(elo_range) %>%
  mutate(win.prop = n / sum(n))

# The estimated aggregated win proportion for white
white.prop <- win.prop[win.prop$winner == "white", ] 
white.p.str.est <- sum(white.prop$win.prop * strata.size.prop)

black.prop <- win.prop[win.prop$winner == "black", ] 
black.p.str.est <- sum(black.prop$win.prop * strata.size.prop)

# The estimated se 
white.se.by.strata <- sqrt((1-nh[2]/Nh[2]) * white.prop$win.prop * (1-white.prop$win.prop)/nh[2])
white.str.se <- sum(strata.size.prop^2 * (1 - nh[2]/Nh[2]) * white.se.by.strata^2)

black.se.by.strata <- sqrt((1-nh[2]/Nh[2]) * black.prop$win.prop * (1-black.prop$win.prop)/nh[2])
black.str.se <- sum(strata.size.prop^2 * (1 - nh[2]/Nh[2]) * black.se.by.strata^2)

# Their difference, 
diff.se <- sqrt(1-n/N) *sqrt(white.p.str.est*(1-white.p.str.est) + black.p.str.est*(1-black.p.str.est) - 2*white.p.str.est*black.p.str.est)/sqrt(n)
(white.p.str.est - black.p.str.est) + z.95 * diff.se * c(-1, 1)

# The confidence interval does not contain 0 so we can reject the null hypothesis in favour of the alternative hypothesis that the win rate of white is larger than that of black

```

``` {r srs openings domain estimation}
# Due to the many possible openings a game can start with,
# the sample size in each possible domain (opening_name) 
# may be very small. In order to ensure that the confidence 
# interval is of reasonable width, we will only estimate if 
# sample size in the domain yields a confidence interval including
# +-0.2 of our estimate.
openings.df.s <- data.frame(table(srs.sample$opening_name))
names(openings.df.s) <- c("name", "frequency")

var.guess <- 0.25
ci.width <- 0.2
n0 <- z.95 ** 2 * var.guess / ci.width ** 2
openings.freq <- openings.df.s[openings.df.s$frequency > 15,]

openings.df.p <- data.frame(table(df$opening_name))
names(openings.df.p) <- c("name", "frequency")
openings.size.p <- openings.df.p[openings.df.p$name %in% openings.freq$name,]

domain.sizes <- c()
for (name in openings.freq$name) {
  domain.sizes <- append(domain.sizes, n0 / (1 + n0 / openings.df.p[openings.df.p$name == name,]$frequency))
}
openings.valid <- openings.freq[openings.freq$frequency > domain.sizes,]

estimates <- rep(0, nrow(openings.valid))
intervals <- matrix(0, nrow(openings.valid), 2)
for (i in 1:nrow(openings.valid)) {
  domain.name <- openings.valid[i, 1]
  domain.s <- srs.sample[srs.sample$opening_name == domain.name,]
  n.d <- openings.valid[i, 2]
  domain.p <- df[df$opening_name == domain.name,]
  N.d <- nrow(domain.p)
  
  white.win.count <- nrow(domain.s[domain.s$winner == "white",])
  black.win.count <- nrow(domain.s[domain.s$winner == "black",])
  white.p <- white.win.count / n.d
  black.p <- black.win.count / n.d
  estimates[i] <- white.p - black.p
  
  white.se <- sqrt((1 - n.d / N.d) * white.p * (1 - white.p) / n.d)
  black.se <- sqrt((1 - n.d / N.d) * black.p * (1 - black.p) / n.d)
  # TODO: make functions
  diff.se <- sqrt(1-n.d/N.d) *sqrt(white.p*(1-white.p) + black.p*(1-black.p) - 2*white.p*black.p)/sqrt(n.d)
  
  intervals[i,] <- (white.p - black.p) + z.95 * diff.se * c(-1, 1)
}

openings <- data.frame(openings.valid$name, intervals)
colnames(openings) <- c("name", "95.CI.lower", "95.CI.upper")
white.higher <- openings[openings$`95.CI.lower` > 0,]
white.lower <- openings[openings$`95.CI.upper` < 0,]
white.higher
white.lower
```

``` {r stratified openings domain estimation}
estimates <- rep(0, nrow(openings.valid))
intervals <- matrix(0, nrow(openings.valid), 2)
for (i in 1:nrow(openings.valid)) {
  domain.name <- openings.valid[i, 1]
  domain.s <- stratified_sample[stratified_sample$opening_name == domain.name,]
  n.d <- openings.valid[i, 2]
  domain.p <- df[df$opening_name == domain.name,]
  N.d <- nrow(domain.p)

  nh.d <- domain.s %>% count(elo_range, .drop=FALSE)
  Nh.d <- domain.p %>% count(elo_range, .drop=FALSE)
  strata.size.prop <- Nh.d[2]/N.d
  
  # Calculate white's win proportion by each strata
  win.prop <- domain.s %>%
    count(winner) %>%
    group_by(elo_range, .drop=FALSE) %>%
    mutate(win.prop = n / sum(n))
  white.p <- win.prop[win.prop$winner == "white", ] 
  white.p.str.est <- sum(white.prop$win.prop * strata.size.prop)
  
  black.p <- win.prop[win.prop$winner == "black", ] 
  black.p.str.est <- sum(black.prop$win.prop * strata.size.prop)
  
  white.se.by.strata <- sqrt((1-n.d/N.d) * white.p$win.prop * (1-white.p$win.prop)/nh.d[2])
  white.str.se <- sum(strata.size.prop^2 * (1 - nh.d[2]/Nh.d[2]) * white.se.by.strata^2)
  
  black.se.by.strata <- sqrt((1-n.d/N.d) * black.p$win.prop * (1-black.p$win.prop)/nh.d[2])
  black.str.se <- sum(strata.size.prop^2 * (1 - nh.d[2]/Nh.d[2]) * black.se.by.strata^2)
  
  diff.se <- sqrt(1-n.d/N.d) *sqrt(white.p.str.est*(1-white.p.str.est) + black.p.str.est*(1-black.p.str.est) - 2*white.p.str.est*black.p.str.est)/sqrt(n.d)
  (white.p.str.est - black.p.str.est) + z.95 * diff.se * c(-1, 1)
  
  estimates[i] <- white.p.str.est - black.p.str.est
  intervals[i,] <- (white.p.str.est - black.p.str.est) + z.95 * diff.se * c(-1, 1)
}

openings <- data.frame(openings.valid$name, intervals)
colnames(openings) <- c("name", "95.CI.lower", "95.CI.upper")
white.higher <- openings[openings$`95.CI.lower` > 0,]
white.lower <- openings[openings$`95.CI.upper` < 0,]
openings
```

``` {r continuous parameter}
# mean number of turns for white wins vs black wins?
white.win <- srs.sample[srs.sample$winner == "white",]
black.win <- srs.sample[srs.sample$winner == "black",]

white.win.turns.avg <- mean(white.win$turns)
black.win.turns.avg <- mean(black.win$turns)
```

### Conclusion
\pagebreak
\begin{center}
\Large{References}
\end{center}


