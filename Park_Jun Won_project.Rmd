---
output: 
  pdf_document:
    citation_package: natbib
    keep_tex: true
    fig_caption: true
    latex_engine: xelatex
    template: https://raw.githubusercontent.com/svmiller/svm-r-markdown-templates/master/svm-latex-ms.tex
title: "White Advantage in Chess and How to Counter It"
author:
- name: Jun Won (Lakon) Park (Group Leader)
  affiliation: 79453940, Group Leader, data collection, data analysis, report-writing
- name: Sarah Li
  affiliation: 60136959, data collection, data analysis, report-writing
abstract: "Research question: Is white at an advantage in chess and if so, what are some optimal strategies for black to increase their winning probability?"
date: "`r format(Sys.time(), '%B %d, %Y')`"
geometry: margin=1in
fontfamily: mathpazo
fontsize: 11pt
# spacing: double
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(leaps)
library(lubridate)
library(stringr)
library(MASS)
library(car)
library(boot)
library(sjPlot)
library(sjmisc)
library(sjlabelled)
library(stargazer)
library(tidyverse)
```

### Introduction
For several centuries, millions of people worldwide have been playing chess as a recreational and competitive board game at their homes, in clubs, in tournaments, and even online nowadays. In the recent decades, chess has been one of the most popular topic in machine learning and artificial intelligence. The first move advantage has been researched extensively since the end of 18th century, and many studies have been shown that white has an inherent advantage.   
\newline
Although there are general set chess openings for black according to white's first move, less research has been done on the effects of those openings on the final outcome. This paper intends to confirm white's first move advantage and study the relationship between the openings and the victory status.  
\newline
This paperâ€™s data collection consists basic player information and game information of over 20000 chess games obtained exclusively from Lichess, a very popular internet chess platform. The data includes game length, number of turns, winner, player elo$^*$, all moves in Standard Chess Notation, Opening Eco$^*$, Opening Name, and Opening Ply$^*$ (some stuff about sampling method and target population)
\newline
\newline
----------------------------------------------------------
\begin{flushleft}
Elo : A numerical measurement to quantify a player's skill level\newline
Eco : Standardised code for any given opening\newline
Ply : Number of moves in the opening phasenewline
\pagebreak
\end{flushleft}
----------------------------------------------------------
\begin{flushleft}
\end{flushleft}

### Analysis

```{r srs}
# Load data
df <- read.csv("games.csv")

# Calculate the average elo of the game
df <- mutate(df %>% rowwise(),
       average_elo = rowMeans(cbind(black_rating,white_rating)))

# Filter games by average elo
df <- filter(df, average_elo > 1200)

# Filter games by average elo
df <- filter(df, victory_status != "outoftime")

df <- subset(df, 
             select = c(turns, white_rating, black_rating, victory_status, 
                        winner, moves, opening_eco, opening_name, opening_ply, average_elo ))

# Simple Random Sampling
N <- nrow(df)
n <- 1000
set.seed(1234)
sample.index <- sample(1:N, size=n, replace = FALSE)
srs.sample <- df[sample.index,]
```


```{r stratified}
# Determine minimum and maximum before stratifying
min(df$average_elo)
max(df$average_elo)

# Stratified sampling
df$elo_range <- cut(df$average_elo, 
                    c(1200, 1400, 1600, 1800, 2000, 2200, 2400, 2600))
levels(df$elo_range) <- c("1200-1400", "1400-1600", "1600-1800", "1800-2000", 
                          "2000-2200", "2200-2400", "2400+")
df$winner <- as.factor(df$winner)
levels(df$winner) <- list("white"=c("white"), 
                          "not_white"=c("black", "draw"))

# Check if standard deviations of the strata are identical
se <- aggregate(as.numeric(df$winner), by=list(df$elo_range), FUN=sd)
se

# Standard deviations within strata are not identical, \
# so find optimal sample sizes
pop_sizes <- aggregate(df$winner, by=list(df$elo_range), FUN=length)
denom <- sum(pop_sizes[2] * se[2])
sample_sizes <- (pop_sizes[2] * se[2]) / denom

# Sample from each strata
stratified_sample <- df[FALSE,]
colnames(stratified_sample) <- names(df)
for (i in 1:length(levels(df$elo_range))) {
  strata <- which(df$elo_range == levels(df$elo_range)[i])
  sample_indices <- sample(strata, 
                           size = ceiling(sample_sizes$x[i] * n), 
                           replace = FALSE)
  sample <- df[sample_indices,]
  stratified_sample <- rbind(stratified_sample, sample)
}
table <- table(stratified_sample$elo_range)
table

# Stratified sample contains 1003 samples due to rounding of the proportions,
# so we randomly remove three from the largest strata (???)
to_remove <- sample(which(stratified_sample$elo_range == "1200-1400"), 1)
stratified_sample <- stratified_sample[-to_remove,]
to_remove <- sample(which(stratified_sample$elo_range == "1400-1600"), 1)
stratified_sample <- stratified_sample[-to_remove,]
to_remove <- sample(which(stratified_sample$elo_range == "1600-1800"), 1)
stratified_sample <- stratified_sample[-to_remove,]
table(stratified_sample$elo_range)
```

### Conclusion
\pagebreak
\begin{center}
\Large{References}
\end{center}


